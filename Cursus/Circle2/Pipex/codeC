/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   backslashes.c                                      :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: angmarti <angmarti@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2023/04/06 18:23:10 by angmarti          #+#    #+#             */
/*   Updated: 2023/05/16 18:03:55 by angmarti         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../incs/pipex.h"

// void	remove_backslash(t_list **lst)
// {
// 	t_list	*node;
// 	char	*str;
// 	int		i;
// 	char	**chararr;

// 	node = *lst;
// 	while (node)
// 	{
// 		if (!ft_strchr(node->content, '\\'))
// 		{
// 			node = node->next;
// 			continue ;
// 		}
// 		i = -1;
// 		str = ft_strdup("");
// 		chararr = ft_split(node->content, '\\');
// 		while (chararr[++i])
// 			str = ft_strjoin_n_free_op(str, chararr[i], 1, 0);
// 		ft_freechararr(chararr);
// 		free(node->content);
// 		node->content = str;
// 		node = node->next;
// 	}
// }
// int	count_not_slashed_words(char const *s, char c)
// {
// 	// int	slashed;
// 	int	count;
// 	int	i;

// 	i = 0;
// 	count = 0;
// 	if (*s && *s != c)
// 		count++;
// 	while (s[++i])
// 		if (s[i - 1] == c && s[i] != c)
// 			count++;
// 	return (count);
// }

// // split_not_escaped(char const *s, char c);

// void	_remove_notescaped_backslash(char *str)
// {
// 	char	*slash;
// 	// int		words;

// 	slash = str;
// 	// words = ft_count_slashed_words(str);
// }
// void	remove_notescaped_backslash(t_list **lst)
// {
// 	t_list	*node;

// 	node = *lst;
// 	while (node)
// 	{
// 		_remove_notescaped_backslash(node->content);
// 		node = node->next;
// 	}
// }

/**
 * The function counts the number of escaped characters in a given string..
 * 
 * @param str String to check.
 * 
 * @return int Number of times a character is escaped.
 */
int	count_escapes(char const *str)
{
	int	count;

	count = 0;
	while (*str)
	{
		if (*str == '\\')
		{
			str++;
			count++;
		}
		if (*str)
			str++;
	}
	return (count);
}
// {
// 	int count;

// 	count = 0;
// 	while (*str)
// 	{
// 		if (*str == '\\')
// 		{
// 			if (*(str + 1) == '\\')
// 				str++;
// 			count++;
// 		}
// 		str++;
// 	}
// 	return (count);
// }

/**
 * This function removes escape characters from a string in node 
 * in a linked list.
 * 
 * @param elem Node in a linked list.
 */
char	*str_remove_escapes(char *str)
{
	char	*aux;
	char	*new_str;
	int		i;
	int		escapes;

	escapes = count_escapes(str);
	new_str = ft_calloc(ft_strlen(str) - escapes + 1, sizeof(char));
	if (!new_str)
		return (NULL);
	i = 0;
	aux = str;
	while (*aux)
	{
		if (*aux == '\\')
		{
			aux++;
		}
		new_str[i++] = *aux;
		aux++;
	}
	return (new_str);
}

/**
 * This function removes escape characters from a string in node 
 * in a linked list.
 * 
 * @param elem Node in a linked list.
 */
void	_remove_escapes(t_list *elem)
{
	int		escapes;
	char	*new_str;
	int		i;
	char	*str;

	escapes = count_escapes(elem->content);
	new_str = ft_calloc(ft_strlen(elem->content) - escapes + 1, sizeof(char));
	if (!new_str)
		return ;
	i = 0;
	str = elem->content;
	while (*str)
	{
		if (*str == '\\')
		{
			str++;
		}
		new_str[i++] = *str;
		str++;
	}
	free(elem->content);
	elem->content = new_str;
}

/**
 * Removes escape characters from the content of the elems in a linked list.
 * 
 * @param lst Linked list
 */
void	remove_escapes(t_list **lst)
{
	t_list	*node;
	char	*new_content;

	node = *lst;
	while (node)
	{
		new_content = str_remove_escapes(node->content);
		free(node->content);
		node->content = new_content;
		node = node->next;
	}
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   case2cmds.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: angmarti <angmarti@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2023/03/08 14:43:05 by angmarti          #+#    #+#             */
/*   Updated: 2023/05/05 17:35:01 by angmarti         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../incs/pipex.h"

void	child(t_vars *vars, int *pipe_fd)
{
	int	fd_infile;

	check_cmd(vars->cmds[0], vars->path);
	fd_infile = open(vars->infile, O_RDONLY);
	if (fd_infile == -1)
		pf_exit("Not accessible input file", STDERR_FILENO);
	dup2(fd_infile, STDIN_FILENO);
	dup2(pipe_fd[1], STDOUT_FILENO);
	close(pipe_fd[0]);
	exec_cmd(vars->cmds[0], vars->path, vars->envp);
}

void	parent(t_vars *vars, int *pipe_fd)
{
	int	fd_outfile;

	check_cmd(vars->cmds[1], vars->path);
	fd_outfile = open(vars->outfile, O_CREAT | O_RDWR | O_TRUNC, 0644);
	if (fd_outfile == -1)
		pf_exit("Not accessible output file", STDERR_FILENO);
	dup2(pipe_fd[0], STDIN_FILENO);
	dup2(fd_outfile, STDOUT_FILENO);
	close(pipe_fd[1]);
	exec_cmd(vars->cmds[1], vars->path, vars->envp);
}

void	case2cmds(t_vars *vars)
{
	int		pipe_fd[2];
	pid_t	pid;

	if (pipe(pipe_fd) == -1)
	{
		perror("\033[1;31mPipe error: ");
		exit(EXIT_FAILURE);
	}
	pid = fork();
	if (pid == -1)
	{
		perror("\033[1;31mError while forking.");
		exit(EXIT_FAILURE);
	}
	if (pid == 0)
		child(vars, pipe_fd);
	else
		parent(vars, pipe_fd);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   case_n_cmds.c                                      :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: angmarti <angmarti@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2023/03/08 14:43:05 by angmarti          #+#    #+#             */
/*   Updated: 2023/05/19 18:01:08 by angmarti         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../incs/pipex.h"

/**
 * It opens the input file and returns the file descriptor
 * 
 * @param infile the name of the file to open
 * @param flags O_RDONLY, O_RDWR
 * 
 * @return The file descriptor of the input file.
 */
int	open_in(char *infile, int flags)
{
	int	fd_infile;

	fd_infile = open(infile, flags);
	if (fd_infile == -1)
	{
		print_stderr("pipex: permission denied: ");
		pf_exit(infile, STDERR_FILENO);
	}
	return (fd_infile);
}

/**
 * It opens the output file and returns the file descriptor
 * 
 * @param outfile the name of the file to open
 * @param flags O_WRONLY, O_CREAT, O_TRUNC, O_APPEND
 * @param mode The mode is specified in octal, and is the same as the mode 
 * argument to open(2).
 * 
 * @return The file descriptor of the output file.
 */
int	open_out(char *outfile, int flags, int mode, int pid)
{
	int	fd_outfile;

	fd_outfile = open(outfile, flags, mode);
	if (fd_outfile == -1)
	{
		if (pid)
			exit(EXIT_FAILURE);
		print_stderr("pipex: permission denied: ");
		pf_exit(outfile, STDERR_FILENO);
	}
	return (fd_outfile);
}

void	n_child(t_vars *vars, int *pipe_fd)
{
	int	fd_infile;

	check_cmd(vars->cmds[0], vars->path);
	fd_infile = open_in(vars->infile, O_RDONLY);
	dup2(fd_infile, STDIN_FILENO);
	dup2(pipe_fd[1], STDOUT_FILENO);
	close(pipe_fd[0]);
	exec_cmd(vars->cmds[0], vars->path, vars->envp);
}

void	n_parent(t_vars *vars, int *pipe_fd, int fd_out, int cmd)
{
	check_cmd(vars->cmds[cmd], vars->path);
	// ft_freechararr(vars->cmds);
	// ft_freechararr(vars->path);
	ft_printf("cmd: %s\n", vars->cmds[cmd]);
	exit(0);
	dup2(pipe_fd[0], STDIN_FILENO);
	dup2(fd_out, STDOUT_FILENO);
	close(pipe_fd[1]);
	exec_cmd(vars->cmds[cmd], vars->path, vars->envp);
}

void	case_n_cmds(t_vars *vars, int *prev_fd, int n_comands)
{
	int		pipe_fd[2];
	pid_t	pid;
	int		fd_outfile;
	
	if (n_comands == 1)
	{
		n_child(vars, prev_fd);
		return ;
	}
	if (pipe(pipe_fd) == -1)
		my_perror("\033[1;31mPipe error: ");
	pid = fork();
	if (pid == -1)
		my_perror("\033[1;31mError while forking.");
	if (!prev_fd)
		fd_outfile = open_out(vars->outfile, O_CREAT | O_RDWR | O_TRUNC, 0644,
				pid);
	else
		fd_outfile = prev_fd[1];
	if (pid == 0)
		case_n_cmds(vars, pipe_fd, n_comands - 1);
	else
		n_parent(vars, pipe_fd, fd_outfile, n_comands - 1);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   checking_setting.c                                 :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: angmarti <angmarti@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2023/03/16 18:31:18 by angmarti          #+#    #+#             */
/*   Updated: 2023/05/19 17:23:36 by angmarti         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../incs/pipex.h"

/**
 * It checks if a command exists in the path
 * 
 * @param cmd the command to check
 * @param path the path to the command
 */
void	check_cmd(char *cmd, char **path)
{
	char	*file;

	file = get_cmd_file(cmd, path);
	if (access(cmd, F_OK) == 0 && !file)
	{
		print_stderr("pipex: permission denied: ");
		print_stderr(cmd);
		print_stderr("\n");
	}
	else if (!file)
	{
		print_stderr("pipex: command not found: ");
		print_stderr(cmd);
		print_stderr("\n");
	}
}

/**
 * The function sets variables in a t_vars struct
 * 
 * @param argc Number of arguments passed to the program
 * @param argv Arguments passed to the program
 * @param vars Variables used in the program.
 */
void	set_vars(int argc, char **argv, t_vars *vars)
{
	int	i;

	vars->here_doc = 0;
	if (ft_strncmp(argv[1], "here_doc", 8) == 0)
	{
		vars->here_doc = 1;
		vars->infile = TEMP_HERE_DOC;
		heredoc(argv[2]);
	}
	else
		vars->infile = argv[1];
	vars->outfile = argv[argc - 1];
	vars->cmds = ft_calloc(argc - (2 + vars->here_doc), sizeof(char *));
	if (!vars->cmds)
		pf_exit("Malloc error", STDERR_FILENO);
	i = 1 + vars->here_doc;
	while (++i < argc - 1)
		vars->cmds[i - (2 + vars->here_doc)] = argv[i];
}

/**
 * It checks:
 * 		the number of arguments, 
 * 		and if the environment variables are set.
 * Also sets:
 * 		the vars path, 
 * 		infile, 
 * 		outfile, 
 * 		and cmds.
 * @param argc Number of arguments passed to the program
 * @param argv Arguments passed to the program
 * @param envp Environment variables
 * @param vars Variables used in the program.
 */
void	check_errors(int argc, char **argv, char **envp, t_vars *vars)
{
	int		i;
	char	*tmp;

	i = argc;
	while (--i > 1)
	{
		tmp = ft_strtrim(argv[i], " \t\v\f\r");
		if (!tmp || !*tmp)
			pf_exit("Wrong arguments.", 1);
		free(tmp);
	}
	if (argc < 5)
	{
		ft_printf("Usage: %s infile", argv[0]);
		pf_exit(" command1 command2 [... commandN] outfile", 1);
	}
	i = 0;
	while (envp && envp[i] && ft_strncmp(envp[i], "PATH=", 5))
		i++;
	if (!envp || !envp[i])
	{
		// i = 1;
		// while (++i < argc - 1)
		// {
		// 	ft_printf("pipex: command not found: ");
		// 	ft_printf("%s", ft_split(argv[i], ' ')[0]);
		// 	ft_printf("\n");
		// }
		// print_stderr("PATH not set.");
		exit(0);
	}
	vars->path = get_path(envp);
	vars->envp = envp;
	set_vars(argc, argv, vars);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   errors.c                                           :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: angmarti <angmarti@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2023/05/05 16:42:37 by angmarti          #+#    #+#             */
/*   Updated: 2023/05/17 16:49:55 by angmarti         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../incs/pipex.h"

/**
 * It prints the error message associated with the last system call, 
 * and then exits the program
 * 
 * @param s The string to print.
 */
void	my_perror(char *s)
{
	perror(s);
	exit(EXIT_FAILURE);
}

/**
 * The function prints a given string to the standard error output in red color.
 * 
 * @param str String that will be printed to the standard error output (stderr).
 */
void	print_stderr(char *str)
{
	ft_putstr_fd(TEXT_RED, STDERR_FILENO);
	ft_putstr_fd(str, STDERR_FILENO);
	ft_putstr_fd(TEXT_RESET, STDERR_FILENO);
}

/**
 * Prints a given string in red and exits the program with a failure status.
 * 
 * @param s the error message to be printed
 */
void	pf_exit(char *s, int fd)
{
	if (fd == STDERR_FILENO)
	{
		print_stderr(s);
		print_stderr("\n");
	}
	else
	{
		ft_putstr_fd(s, fd);
		ft_putstr_fd("\n", fd);
	}
	exit(EXIT_FAILURE);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_functions.c                                     :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: angmarti <angmarti@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2023/02/09 17:03:40 by angmarti          #+#    #+#             */
/*   Updated: 2023/05/16 18:14:41 by angmarti         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../incs/pipex.h"

/**
 * It frees an array of strings.
 * 
 * @param chararr The array of strings to be freed.
 */
void	ft_freechararr(char **chararr)
{
	int	i;

	i = -1;
	while (chararr[++i])
		free(chararr[i]);
	free(chararr);
}

/**
 * It joins two strings and frees the memory of the two strings.
 * 
 * @param s1 The first string to be joined.
 * @param s2 the string to be appended to s1
 * 
 * @return A pointer to the newly allocated string.
 */
char	*ft_strjoin_n_free(const char *s1, const char *s2)
{
	char	*result;

	if (!s1)
		return (NULL);
	if (!s2)
	{
		result = ft_strjoin(s1, "");
		free((char *)s1);
		return (result);
	}
	result = ft_strjoin(s1, s2);
	free((char *)s1);
	free((char *)s2);
	return (result);
}

/**
 * It joins two strings and frees the memory of the strings if the flag is set.
 * 
 * @param s1 The first string to join.
 * @param s2 The string to be appended to s1.
 * @param f1 if not 0, free s1
 * @param f2 if not 0, free s2
 * 
 * @return A pointer to a string, NULL if it fails.
 */
char	*ft_strjoin_n_free_op(const char *s1, const char *s2, int f1, int f2)
{
	char	*result;

	if (!s1)
		return (NULL);
	if (!s2)
	{
		result = ft_strjoin(s1, "");
		free((char *)s1);
		return (result);
	}
	result = ft_strjoin(s1, s2);
	if (f1)
		free((char *)s1);
	if (f2)
		free((char *)s2);
	return (result);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_split_not_escaped.c                             :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: angmarti <angmarti@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2022/07/10 13:30:02 by angmarti          #+#    #+#             */
/*   Updated: 2023/05/15 14:58:10 by angmarti         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../incs/pipex.h"

/**
 * The function counts the number of escaped characters in a given string 
 * between two indices.
 * 
 * @param str String to check.
 * @param start Index of the first character to check.
 * @param end Index of the last character to check.
 * @param c Character to check.
 * 
 * @return int Number of times the character `c` is escaped.
 */
int	count_escaped_chars(char const *str, int start, int end, char c)
{
	int	count;

	count = 0;
	while (start < end)
	{
		if (str[start] == '\\' && str[start + 1] == c)
		{
			count++;
			start++;
		}
		else
			start++;
	}
	return (count);
}

/**
 * Returns a copy of a given string with removed escape characters 
 * for a specific character.
 * 
 * @param str String to be copied 
 * @param start Starting index
 * @param end Last index
 * @param c Character that is used to identify escape sequences in the string
 * 
 * @return A copy that not includes any escape sequences for the character `c`.
 */
char	*get_strcpy_no_c_escapes(char const *str, int start, int end, char c)
{
	char	*cpy;
	int		i;
	int		escaped_chars;

	if (start >= end)
		ft_printf("Error: start == end\n");
	i = -1;
	escaped_chars = count_escaped_chars(str, start, end, c);
	cpy = ft_calloc(sizeof(char), end - start + 1 - escaped_chars);
	if (!cpy)
		return (NULL);
	i = 0;
	while (start < end)
	{
		if (str[start] == '\\' && str[start + 1] == c)
			start++;
		cpy[i++] = str[start];
		start++;
	}
	return (cpy);
}

/**
 * Counts the number of words in a string that are not escaped by 
 * a given character.
 * 
 * @param s String we want to count words in.
 * @param c Character that separates the words in the string.
 * @param str_len The length of the string `s`.
 * 
 * @return The number of words in the string `s`.
 */
int	count_words_not_escaped(char const *s, char c, int str_len)
{
	int	start;
	int	end;
	int	words;

	words = 0;
	start = -1;
	while (++start < str_len)
	{
		end = start;
		while (end < str_len)
		{
			if (s[end] == '\\' && s[end + 1] == c)
				end++;
			else if (s[end] == c)
				break ;
			end++;
		}
		if (start < str_len)
			words++;
		start = end;
	}
	return (words);
}

/**
 * Splits a string into words based on a given delimiter and stores them in 
 * an array of strings.
 * 
 * @param words Array of strings to store the words.
 * @param s String to be splited.
 * @param c Delimiter character.
 * @param str_len The length of the string `s`.
 */
void	set_words(char **wordarr, char const *s, char c, int str_len)
{
	int	start;
	int	end;
	int	i;

	start = -1;
	i = 0;
	while (++start < str_len)
	{
		end = start;
		while (end < str_len)
		{
			if (s[end] == '\\' && s[end + 1] == c)
				end++;
			else if (s[end] == c)
				break ;
			end++;
		}
		if (start < str_len && start < end)
			wordarr[i++] = get_strcpy_no_c_escapes(s, start, end, c);
		start = end;
	}
}

/**
 * Splits a string into an array of substrings based on a delimiter character,
 * while ignoring escaped instances of the delimiter.
 * 
 * @param s String to be splite
 * @param c Delimiter character.
 * 
 * @return An array of strings
 */
char	**ft_split_not_escaped(char const *s, char c)
{
	char	**array;
	int		words;
	int		str_len;

	words = 0;
	str_len = (int)ft_strlen(s);
	array = ft_calloc(sizeof(char *), 1);
	words = count_words_not_escaped(s, c, str_len);
	array = ft_calloc(sizeof(char *), words + 1);
	if (!array)
		return (NULL);
	set_words(array, s, c, str_len);
	return (array);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   get_cmd_args.c                                     :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: angmarti <angmarti@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2023/04/06 18:23:10 by angmarti          #+#    #+#             */
/*   Updated: 2023/05/17 17:43:51 by angmarti         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../incs/pipex.h"

int	is_escaped_quote(char const *cmd, int i)
{
	if (cmd[i] == '\'' || cmd[i] == '\"')
	{
		if (i == 0)
			return (0);
		if (cmd[i - 1] == '\\')
			return (1);
	}
	return (0);
}

// int	set_search(char const *cmd, int i, char **search)
// {
// 	if (cmd[i] == ' ')
// 		return (0);
// 	if (cmd[i] == '\'')
// 		*search = "\'";
// 	else if (cmd[i] == '\"')
// 		*search = "\"";
// 	return (1);
// }

// if (*len == 0) // ! CON COMILLAS----------------
// {
// 	if (cmd[*i + *len] == ' ')
// 	{
// 		*i += 1;
// 		*len = -1;
// 	}
// 	else if (cmd[*i] == '\'')
// 		*search = "\'";
// 	else if (cmd[*i] == '\"')
// 		*search = "\"";
// 	return ;
// }
// if (cmd[*i + *len] != ' ')
// 	*len += 1; // CON COMILLAS----------------
// if (*len == 0) // ! SIN COMILLAS-------------
// {
// 	if (cmd[*i] == '\'')
// 		*search = "\'";
// 	else if (cmd[*i] == '\"')
// 		*search = "\"";
// 	*i += 1;
// 	*len = -1;
// 	return ;
// } // SIN COMILLAS--------------------------

int	search_word(char const *cmd, int *i, int *len, char **search)
{
	if (ft_strchr(*search, cmd[*i + *len]) && !is_escaped_quote(cmd, *i + *len))
	{
		if (*len == 0)
		{
			if (cmd[*i] == '\'')
				*search = "\'";
			else if (cmd[*i] == '\"')
				*search = "\"";
			*i += 1;
			*len = -1;
			return (0);
		}
		return (1);
	}
	return (0);
}

void	set_arg_lst(char const *cmd, t_list **arg_lst)
{
	int		i;
	int		len;
	char	*search;
	t_list	*node;

	i = 0;
	len = -1;
	search = " '\"";
	while (cmd && (i + ++len) < (int)ft_strlen(cmd))
	{
		if (search_word(cmd, &i, &len, &search))
		{
			node = ft_lstnew(ft_substr(cmd, i, len));
			ft_lstadd_back(arg_lst, node);
			i += len + 1;
			len = -1;
			search = " '\"";
		}
	}
	if (len > 0)
		ft_lstadd_back(arg_lst, ft_lstnew(ft_substr(cmd, i, len)));
}

char	**lst_to_arr(t_list **lst)
{
	char	**arr;
	t_list	*node;
	int		i;
	int		size;

	size = ft_lstsize(*lst);
	arr = ft_calloc(size + 1, sizeof(char *));
	if (!arr)
		return (NULL);
	node = *lst;
	i = 0;
	while (i < size)
	{
		arr[i] = ft_strtrim((char *)node->content, " \t\n\v\r\f");
		node = node->next;
		i++;
	}
	return (arr);
}

/**
 * Takes a command string and returns an array of its arguments, 
 * splitting them by spaces and/or quotes.
 * 
 * @param cmd A command.
 * 
 * @return An array of strings, each one being an argument of the command.
 */
char	**get_cmd_args(char const *cmd)
{
	t_list	**arg_lst;
	char	**arg_arr;

	if (!ft_strchr(cmd, '\'') && !ft_strchr(cmd, '\"'))
		return (ft_split_not_escaped(cmd, ' '));
	arg_lst = ft_calloc(sizeof(t_list *), 1);
	if (!arg_lst)
		return (NULL);
	set_arg_lst(cmd, arg_lst);
	remove_escapes(arg_lst);
	arg_arr = lst_to_arr(arg_lst);
	return (arg_arr);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   getting_executing.c                                :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: angmarti <angmarti@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2023/03/08 14:44:42 by angmarti          #+#    #+#             */
/*   Updated: 2023/05/19 17:35:52 by angmarti         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../incs/pipex.h"

/**
 * It returns the number of elements in a char **
 * 
 * @param chararr The array of strings to be counted.
 * 
 * @return The number of elements in the array.
 */
int	chararrsize(char **chararr)
{
	int	i;

	i = 0;
	while (chararr[i])
		i++;
	return (i);
}

/**
 * It takes a command and a path, and returns the path to the command
 * 
 * @param cmd the command to be executed
 * @param path The path to the command.
 * 
 * @return The path of the command.
 */
char	*get_cmd_file(char *cmd, char **path)
{
	int		i;
	char	**words;
	char	*result;
	char	*aux;

	if (!cmd)
		return (NULL);
	cmd = str_remove_escapes(cmd);
	if ((cmd[0] == '/' || (cmd[0] == '.' && cmd[1] == '/')) && access(cmd,
			X_OK) == 0)
		return ((char *)cmd);
	i = -1;
	words = ft_split_not_escaped(cmd, ' ');
	result = NULL;
	while (++i < 6)
	{
		aux = ft_strjoin("/", words[0]);
		result = ft_strjoin(path[i], aux);
		free(aux);
		if (access(result, X_OK) == 0)
			break ;
		free(result);
		result = NULL;
	}
	ft_freechararr(words);
	return (result);
}

/**
 * It takes an environment variable array and returns an array of strings 
 * containing the paths in the PATH environment variable
 * 
 * @param envp The environment variables.
 * 
 * @return the path of the environment variable.
 */
char	**get_path(char *envp[])
{
	int	i;

	i = 0;
	while (envp && envp[i] && ft_strncmp(envp[i], "PATH=", 5))
		i++;
	return (ft_split(envp[i] + 5, ':'));
}

/**
 * It takes a command, a path variable and an environment variable, 
 * and returns an array of strings with the command and its arguments
 * 
 * @param cmd the command to be executed.
 * @param path the PATH variable, split by ':'
 * @param envp is the environment variables.
 * 
 * @return The array of arguments.
 */
void	exec_cmd(char *cmd, char **path, char *envp[])
{
	char	**args;
	char	*file;

	args = get_cmd_args(cmd);
	file = get_cmd_file(cmd, path);
	execve(file, args, envp);
	exit(127);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   here_doc.c                                         :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: angmarti <angmarti@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2023/05/18 19:44:51 by angmarti          #+#    #+#             */
/*   Updated: 2023/05/18 20:17:47 by angmarti         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../incs/pipex.h"

int	heredoc(char *limiter)
{
	int fd;
	char *line;

	fd = open(TEMP_HERE_DOC, O_CREAT | O_RDWR | O_TRUNC, 0644);
	if (fd == -1)
		pf_exit("Error opening file", 1);
	line = get_next_line(STDIN_FILENO);
	while (ft_strncmp(line, limiter, ft_strlen(limiter)))
	{
		ft_putstr_fd(line, fd);
		free(line);
		line = get_next_line(STDIN_FILENO);
	}
	close(fd);
	return (0);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   main.c                                             :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: angmarti <angmarti@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2023/03/08 14:43:05 by angmarti          #+#    #+#             */
/*   Updated: 2023/05/19 17:41:14 by angmarti         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../incs/pipex.h"

void	checkpoint(void)
{
	ft_putstr_fd("\033[0m––––____checkpoint____––––\n\033[0m", STDOUT_FILENO);
}

void	leaks(void)
{
	ft_printf("\033[0m\n\n\033[7;49;33m");
	system("leaks -q pipex");
	ft_printf("\033[0m");
}

void	test(char **argv, int j, char **envp)
{
	int		i;
	char	**args;

	printf("%s", TEXT_RESET);
	args = get_cmd_args(argv[j]);
	if (!args[0])
		printf("No args\n");
	else
	{
		printf("%sComand[%d]: ", TEXT_RESET, j + 1);
		i = 1;
		printf("\033[7;49;34m%s\n", argv[j]);
	}
	i = 0;
	while (args[i])
	{
		printf("\033[0m  arg%d: \033[7;49;33m%s\n", i, args[i]);
		i++;
	}
	printf("\033[0m  CmdFile: \033[7;49;33m");
	printf("%s\n\033[1;32m\n", get_cmd_file(argv[j], get_path(envp)));
}

// int	main(void)
// {
// 	char	**array;
// 	int		i;
// 	int		j;
// 	char	**split;

// 	array = ft_calloc(sizeof(char **), 800);
// 	i = 0;
// 	array[i++] = "\\hola\\que\\tal";
// 	array[i++] = "\\\\hola\\\\que\\\\tal";
// 	array[i++] = "\\hola\\ \\que\\\\tal\\\\\\";
// 	// array[i++] = "HOLA QUE TAL";
// 	// array[i++] = "HOLA QUE TAL   ";
// 	// array[i++] = " HOLA QUE TAL   ";
// 	// array[i++] = " HOLA  QUE  TAL   ";
// 	// array[i++] = "HOLA\\ QUE TAL";
// 	// array[i++] = "HOLA \\ QUE TAL";
// 	// array[i++] = "\\  \\  \\  HOLA \\  \\  \\  QUE TAL\\  \\  ";
// 	// array[i++] = "HOLA QUE TAL\\   ";
// 	// array[i++] = "HOLA\\ QUE TAL    ";
// 	// array[i++] = "    HOLA\\     \\ QUE\\   TAL    ";
// 	// array[i++] = "    HOLA\\ \\ QUE\\   TAL    ";
// 	// array[i++] = "\\ HOLA QUE TAL ";
// 	// array[i++] = "   \\ \\ HOLA QUE TAL ";
// 	i = 0;
// 	while (array[i])
// 	{
// 		ft_printf("%s%s%s\n", TEXT_BG_BLUE, array[i], TEXT_RESET);
// 		split = ft_split_not_escaped(array[i], '\\');
// 		j = 0;
// 		while (split[j])
// 		{
// 			printf("Palabra %d: %s%s%s\n", j, TEXT_BG_BRIGHT_YELLOW, split[j],
// TEXT_RESET);
// 			j++;
// 		}
// 		i++;
// 	}
// 	return (0);
// }

int	main(int argc, char **argv, char **envp)
{
	t_vars	vars;
	char	**cmds;
	int		i;

	atexit(leaks);
	if (0 && (argc > 1 && ft_strncmp(argv[1], "test", ft_strlen(argv[1])) == 0))
	{
		ft_printf("\033[7;31m                           \n");
		ft_printf("\033[7;31m         TEST MODE         \n");
		ft_printf("\033[7;31m                           \n");
		cmds = ft_calloc(100, sizeof(char *));
		i = 0;
		cmds[i++] = argv[3];
		cmds[i++] = argv[4];
		i = 0;
		while (cmds[i])
			test(cmds, i++, envp);
		exit(0);
	}
	check_errors(argc, argv, envp, &vars);
	// if (argc == (5 + vars.here_doc))
	// 	case2cmds(&vars);
	// else
	case_n_cmds(&vars, NULL, chararrsize(vars.cmds));
	return (0);
}

// int		count_escapes(char const *str);
// int		count_escaped_chars(char const *str, int start, int end, char c);
// void	_remove_escapes(t_list *elem);
// char	*str_remove_escapes(char *str);
// int	main(void)
// {
// 	char	*str;
// 	// t_list	*elem;
// 	char	*newstr;

// 	// atexit(leaks);
// 	for (size_t i = 0; i < 3; i++)
// 	{
// 		str = "\\\\\\\\\\H\\o\\l\\a\\ \\q\\u\\e\\ \\t\\a\\l\\";
// 		// elem = ft_lstnew(ft_strdup(str));
// 		ft_printf("       str: %s%s%s\n", TEXT_BG_BLUE, str, TEXT_RESET);
// 		newstr = str_remove_escapes(str);
// 		ft_printf("str no esc: %s%s%s\n", TEXT_BG_BLUE, newstr,
// 				TEXT_RESET);
// 		// free(elem);
// 		free(newstr);
// 	}
// 	atexit(leaks);
// 	return (0);
// }
